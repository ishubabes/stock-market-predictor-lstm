import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import classification_report

def analyze_stock(ticker, period="10y", interval="1d"):
    print(f"\nLoading data for {ticker}...")
    try:
        df = yf.download(ticker, period=period, interval=interval)
        df.reset_index(inplace=True)
        df = df[['Date', 'Open', 'High', 'Low', 'Close', 'Volume']].dropna()
        print(f"Loaded {len(df)} rows for {ticker}.")

        df['Price_Change'] = df['Close'].pct_change()
        df['Target'] = (df['Price_Change'].shift(-1) > 0).astype(int)
        df.dropna(inplace=True)
        
        return df
    except Exception as e:
        print(f"‚ùå Error loading data for {ticker}: {e}")
        return None

def train_evaluate_model(X, y, model, model_name):
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)
    
    X_train, X_test, y_train, y_test = train_test_split(
        X_scaled, y, test_size=0.2, shuffle=False, random_state=42
    )
    
    model.fit(X_train, y_train)
    pred = model.predict(X_test)
    report = classification_report(y_test, pred, output_dict=True, zero_division=0)
    
    print(f"\n{model_name}:")
    print(classification_report(y_test, pred, zero_division=0))
    
    latest_features = X_scaled[-1].reshape(1, -1)
    latest_pred = model.predict(latest_features)[0]
    
    return {
        'accuracy': report['accuracy'],
        'latest_pred': latest_pred,
        'model': model,
        'scaler': scaler
    }

def perform_analysis(ticker):
    df = analyze_stock(ticker)
    if df is None:
        return None
    
    features = ['Open', 'High', 'Low', 'Close', 'Volume']
    X = df[features]
    y = df['Target']
    
    models = {
        'Logistic Regression': LogisticRegression(max_iter=1000, random_state=42),
        'Random Forest': RandomForestClassifier(n_estimators=100, random_state=42),
        'SVM': SVC(random_state=42),
        'KNN': KNeighborsClassifier(n_neighbors=5)
    }
    
    results = {}
    for name, model in models.items():
        results[name] = train_evaluate_model(X, y, model, name)
    
    recommendation = "BUYING" if results['Random Forest']['latest_pred'] == 1 else "NOT BUYING (SELL/HOLD)"
    print(f"\nüìå {ticker} Recommendation based on Random Forest model:")
    print(f"üëâ The model suggests *{recommendation}* the stock.")
    
    return results

def analyze_market_caps(tickers):
    market_caps = {}
    missing_caps = []
    
    nasdaq_100_tickers = [
        'AAPL', 'MSFT', 'AMZN', 'GOOGL', 'NVDA', 'TSLA', 'META', 'NFLX',
        'INTC', 'CSCO', 'PEP', 'ADBE', 'CMCSA', 'COST', 'TXN', 'AVGO', 'QCOM',
        'AMD', 'AMGN', 'CHTR', 'BKNG', 'ISRG', 'FISV', 'SBUX', 'MDLZ', 'INTU',
    ]
    
    print("\nüîç Fetching live market capitalizations...")
    for ticker in tickers:
        try:
            if ticker == 'NDX':
                total_ndx_cap = 0
                for comp in nasdaq_100_tickers:
                    try:
                        cap = yf.Ticker(comp).info.get('marketCap', 0)
                        total_ndx_cap += cap if cap else 0
                    except Exception as e:
                        print(f"‚ùå Failed to get market cap for {comp}: {e}")
                market_caps[ticker] = total_ndx_cap / 1e9
                print(f"‚úî Calculated NDX market cap based on components: ${market_caps[ticker]:.2f}B")
                continue
                
            info = yf.Ticker(ticker).info
            cap = info.get('marketCap')
            if cap:
                market_caps[ticker] = cap / 1e9
                print(f"‚úî {ticker}: ${market_caps[ticker]:.2f}B")
            else:
                missing_caps.append(ticker)
                print(f"‚ö† Market cap not available for {ticker}")
        except Exception as e:
            print(f"‚ùå Failed to fetch data for {ticker}: {e}")
            missing_caps.append(ticker)
    
    if missing_caps:
        print(f"\n‚ö† Missing market caps for: {', '.join(missing_caps)}")
    
    return market_caps

def visualize_market_caps(market_caps):
    total_market_cap = sum(market_caps.values())
    weights = {stock: cap / total_market_cap for stock, cap in market_caps.items()}

    print("\nüìä Stock Weights based on Live Market Capitalization:")
    for stock, weight in weights.items():
        print(f"{stock}: {weight:.4f} ({weight*100:.2f}%)")

    plt.figure(figsize=(10, 8))
    plt.pie(weights.values(), labels=weights.keys(), 
            autopct='%1.1f%%', startangle=140, 
            colors=plt.cm.tab20.colors)
    plt.title('Market Capitalization Weights (in billions USD)', pad=20)
    plt.axis('equal')
    plt.tight_layout()
    plt.show()

if _name_ == "_main_":
    aapl_results = perform_analysis('AAPL')
    ndx_results = perform_analysis('^NDX')
    
    tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'NVDA', 'TSLA', 'META', 'NFLX', 'BRK-B', 'NDX']
    market_caps = analyze_market_caps(tickers)
    
    if market_caps:
        visualize_market_caps(market_caps)
    
    if aapl_results and ndx_results:
        plt.figure(figsize=(10, 6))
        x = np.arange(len(aapl_results))
        width = 0.35
        
        aapl_acc = [aapl_results[m]['accuracy'] for m in aapl_results]
        ndx_acc = [ndx_results[m]['accuracy'] for m in ndx_results]
        
        plt.bar(x - width/2, aapl_acc, width, label='AAPL')
        plt.bar(x + width/2, ndx_acc, width, label='NDX')
        
        plt.xlabel('Model')
        plt.ylabel('Accuracy')
        plt.title('Model Accuracy Comparison: AAPL vs NDX')
        plt.xticks(x, aapl_results.keys(), rotation=45)
        plt.legend()
        plt.tight_layout()
        plt.show()
